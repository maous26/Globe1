// server/services/flight/routeMonitor.js
const cron = require('node-cron');
const Route = require('../../models/route.model');
const User = require('../../models/user.model');
const Alert = require('../../models/alert.model');
const { searchFlights, checkApiQuota } = require('./flightService');
const { optimizeRoutes } = require('../ai/routeOptimizationService');
const { validateDeal } = require('../ai/dealValidationService');
const { sendAlertEmail } = require('../email/emailService');
const { incrementApiCallStats } = require('../analytics/statsService');

// Map of route tiers to scan frequencies (times per day)
const TIER_SCAN_FREQUENCY = {
  'ultra-priority': 6,
  'priority': 4,
  'complementary': 2
};

// Minimum discount percentages for alerts
const MIN_DISCOUNT_FREE = 30; // 30% for free users
const MIN_DISCOUNT_PREMIUM = 0; // Any discount for premium users

// Maximum alerts per day for free users
const MAX_ALERTS_FREE = 3;

/**
 * Initialize route monitoring with strategic routes
 * @returns {Promise<void>}
 */
exports.initializeRoutes = async () => {
  try {
    // Check if routes are already initialized
    const routeCount = await Route.countDocuments();
    if (routeCount > 0) {
      console.log(`Routes already initialized (${routeCount} routes found)`);
      return;
    }
    
    console.log('Initializing strategic routes...');
    
    // Define airports
    const departureAirports = [
      { code: 'CDG', name: 'Paris Charles de Gaulle' },
      { code: 'ORY', name: 'Paris Orly' },
      { code: 'LYS', name: 'Lyon Saint-Exupéry' },
      { code: 'NCE', name: 'Nice Côte d\'Azur' },
      { code: 'MRS', name: 'Marseille Provence' },
      { code: 'BOD', name: 'Bordeaux-Mérignac' },
      { code: 'TLS', name: 'Toulouse-Blagnac' },
      { code: 'NTE', name: 'Nantes Atlantique' }
    ];
    
    // Define destination categories based on strategic document
    const ultraPriorityDestinations = [
      // Europe from Paris
      { code: 'MAD', name: 'Madrid' },
      { code: 'BCN', name: 'Barcelone' },
      { code: 'LHR', name: 'Londres' },
      { code: 'FCO', name: 'Rome' },
      { code: 'AMS', name: 'Amsterdam' },
      { code: 'MXP', name: 'Milan' },
      { code: 'LIS', name: 'Lisbonne' },
      { code: 'TXL', name: 'Berlin' },
      { code: 'CPH', name: 'Copenhague' },
      { code: 'ZRH', name: 'Zurich' },
      { code: 'DUB', name: 'Dublin' },
      
      // Long-haul from Paris
      { code: 'JFK', name: 'New York' },
      { code: 'YUL', name: 'Montréal' },
      { code: 'LAX', name: 'Los Angeles' },
      { code: 'HND', name: 'Tokyo' },
      { code: 'DXB', name: 'Dubaï' },
      { code: 'CMN', name: 'Casablanca' },
      
      // Domestic from Paris
      { code: 'NCE', name: 'Nice' },
      { code: 'TLS', name: 'Toulouse' },
      { code: 'MRS', name: 'Marseille' },
      { code: 'BOD', name: 'Bordeaux' },
      { code: 'LYS', name: 'Lyon' },
      { code: 'NTE', name: 'Nantes' }
    ];
    
    const priorityDestinations = [
      // From Lyon
      { code: 'MAD', name: 'Madrid' },
      { code: 'LHR', name: 'Londres' },
      { code: 'BCN', name: 'Barcelone' },
      { code: 'FCO', name: 'Rome' },
      { code: 'AMS', name: 'Amsterdam' },
      
      // From Nice
      { code: 'CDG', name: 'Paris' },
      { code: 'LHR', name: 'Londres' },
      { code: 'MXP', name: 'Milan' },
      { code: 'MAD', name: 'Madrid' },
      { code: 'FCO', name: 'Rome' },
      
      // From Marseille
      { code: 'BCN', name: 'Barcelone' },
      { code: 'LHR', name: 'Londres' },
      { code: 'FCO', name: 'Rome' },
      { code: 'AMS', name: 'Amsterdam' },
      { code: 'MAD', name: 'Madrid' },
      
      // From Bordeaux
      { code: 'LHR', name: 'Londres' },
      { code: 'MAD', name: 'Madrid' },
      { code: 'AMS', name: 'Amsterdam' },
      { code: 'ZRH', name: 'Zurich' },
      
      // From Toulouse
      { code: 'MAD', name: 'Madrid' },
      { code: 'LHR', name: 'Londres' },
      { code: 'FCO', name: 'Rome' },
      { code: 'RAK', name: 'Marrakech' },
      
      // From Nantes
      { code: 'LIS', name: 'Lisbonne' },
      { code: 'LHR', name: 'Londres' },
      { code: 'BCN', name: 'Barcelone' },
      { code: 'FAO', name: 'Faro' },
      
      // Additional long-haul
      { code: 'LAX', name: 'Los Angeles' },
      { code: 'MIA', name: 'Miami' },
      { code: 'PHX', name: 'Phoenix' },
      { code: 'MCO', name: 'Orlando' },
      { code: 'GRU', name: 'São Paulo' },
      { code: 'LIM', name: 'Lima' },
      { code: 'SCL', name: 'Santiago' },
      { code: 'SSA', name: 'Salvador de Bahia' },
      { code: 'MRU', name: 'Maurice' },
      { code: 'BKK', name: 'Bangkok' },
      { code: 'SIN', name: 'Singapour' },
      { code: 'MNL', name: 'Manille' },
      { code: 'NBO', name: 'Nairobi' },
      { code: 'BZV', name: 'Brazzaville' },
      { code: 'AUH', name: 'Abou Dhabi' },
      { code: 'RUH', name: 'Riyad' }
    ];
    
    const complementaryDestinations = [
      // Summer destinations
      { code: 'PMI', name: 'Palma de Majorque', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'IBZ', name: 'Ibiza', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'JTR', name: 'Santorin', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'HER', name: 'Héraklion', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'DBV', name: 'Dubrovnik', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'SPU', name: 'Split', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'FNC', name: 'Funchal', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'FAO', name: 'Faro', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'LCA', name: 'Larnaca', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'AYT', name: 'Antalya', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'OLB', name: 'Olbia', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'CAG', name: 'Cagliari', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'CTA', name: 'Catane', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'RUH', name: 'Riyad', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      { code: 'MCO', name: 'Orlando', isSeasonal: true, seasonStart: '2025-05-01', seasonEnd: '2025-09-30' },
      
      // Winter destinations
      { code: 'SXM', name: 'Saint-Martin', isSeasonal: true, seasonStart: '2025-11-01', seasonEnd: '2026-03-31' },
      { code: 'PUJ', name: 'Punta Cana', isSeasonal: true, seasonStart: '2025-11-01', seasonEnd: '2026-03-31' },
      { code: 'SSA', name: 'Salvador de Bahia', isSeasonal: true, seasonStart: '2025-11-01', seasonEnd: '2026-03-31' },
      { code: 'HRG', name: 'Hurghada', isSeasonal: true, seasonStart: '2025-11-01', seasonEnd: '2026-03-31' },
      { code: 'SSH', name: 'Sharm el Sheikh', isSeasonal: true, seasonStart: '2025-11-01', seasonEnd: '2026-03-31' },
      { code: 'ACE', name: 'Lanzarote', isSeasonal: true, seasonStart: '2025-11-01', seasonEnd: '2026-03-31' },
      { code: 'FUE', name: 'Fuerteventura', isSeasonal: true, seasonStart: '2025-11-01', seasonEnd: '2026-03-31' },
      { code: 'SID', name: 'Cap-Vert', isSeasonal: true, seasonStart: '2025-11-01', seasonEnd: '2026-03-31' },
      { code: 'RVN', name: 'Rovaniemi', isSeasonal: true, seasonStart: '2025-11-01', seasonEnd: '2026-03-31' },
      { code: 'TOS', name: 'Tromsø', isSeasonal: true, seasonStart: '2025-11-01', seasonEnd: '2026-03-31' }
    ];
    
    // Create routes
    const routes = [];
    
    // Create ultra-priority routes (primarily from Paris)
    for (const destination of ultraPriorityDestinations) {
      // Skip if destination is a departure airport (to avoid domestic duplicates)
      if (departureAirports.some(dep => dep.code === destination.code)) continue;
      
      routes.push({
        departureAirport: { 
          code: 'CDG', 
          name: 'Paris Charles de Gaulle' 
        },
        destinationAirport: destination,
        tier: 'ultra-priority',
        scanFrequency: TIER_SCAN_FREQUENCY['ultra-priority'],
        isSeasonal: false
      });
      
      // Add ORY version for some routes
      if (['MAD', 'BCN', 'LHR', 'FCO', 'AMS', 'LIS'].includes(destination.code)) {
        routes.push({
          departureAirport: { 
            code: 'ORY', 
            name: 'Paris Orly' 
          },
          destinationAirport: destination,
          tier: 'ultra-priority',
          scanFrequency: TIER_SCAN_FREQUENCY['ultra-priority'],
          isSeasonal: false
        });
      }
    }
    
    // Create priority routes
    for (const destination of priorityDestinations) {
      // From regional airports to major European destinations
      for (const departure of departureAirports.filter(dep => dep.code !== 'CDG' && dep.code !== 'ORY')) {
        // Skip if destination is the same as departure
        if (departure.code === destination.code) continue;
        
        // Only add specific connections based on route document recommendations
        if (
          (departure.code === 'LYS' && ['MAD', 'LHR', 'BCN', 'FCO', 'AMS'].includes(destination.code)) ||
          (departure.code === 'NCE' && ['CDG', 'LHR', 'MXP', 'MAD', 'FCO'].includes(destination.code)) ||
          (departure.code === 'MRS' && ['BCN', 'LHR', 'FCO', 'AMS', 'MAD'].includes(destination.code)) ||
          (departure.code === 'BOD' && ['LHR', 'MAD', 'AMS', 'ZRH'].includes(destination.code)) ||
          (departure.code === 'TLS' && ['MAD', 'LHR', 'FCO', 'RAK'].includes(destination.code)) ||
          (departure.code === 'NTE' && ['LIS', 'LHR', 'BCN', 'FAO'].includes(destination.code))
        ) {
          routes.push({
            departureAirport: departure,
            destinationAirport: destination,
            tier: 'priority',
            scanFrequency: TIER_SCAN_FREQUENCY['priority'],
            isSeasonal: false
          });
        }
      }
      
      // Additional long-haul from CDG for priority routes not in ultra-priority
      if (!ultraPriorityDestinations.some(d => d.code === destination.code) && 
          ['LAX', 'MIA', 'PHX', 'MCO', 'GRU', 'LIM', 'SCL', 'SSA', 'MRU', 'BKK', 'SIN', 'MNL', 'NBO', 'BZV', 'AUH', 'RUH'].includes(destination.code)) {
        routes.push({
          departureAirport: { 
            code: 'CDG', 
            name: 'Paris Charles de Gaulle' 
          },
          destinationAirport: destination,
          tier: 'priority',
          scanFrequency: TIER_SCAN_FREQUENCY['priority'],
          isSeasonal: false
        });
      }
    }
    
    // Create complementary routes (seasonal)
    for (const destination of complementaryDestinations) {
      routes.push({
        departureAirport: { 
          code: 'CDG', 
          name: 'Paris Charles de Gaulle' 
        },
        destinationAirport: {
          code: destination.code,
          name: destination.name
        },
        tier: 'complementary',
        scanFrequency: TIER_SCAN_FREQUENCY['complementary'],
        isSeasonal: destination.isSeasonal,
        seasonalPeriod: destination.isSeasonal ? {
          start: new Date(destination.seasonStart),
          end: new Date(destination.seasonEnd)
        } : undefined
      });
      
      // Add some seasonal routes from major regional airports
      if (['PMI', 'JTR', 'FAO', 'PUJ', 'ACE'].includes(destination.code)) {
        for (const departure of departureAirports.filter(dep => ['LYS', 'NCE', 'MRS'].includes(dep.code))) {
          routes.push({
            departureAirport: departure,
            destinationAirport: {
              code: destination.code,
              name: destination.name
            },
            tier: 'complementary',
            scanFrequency: TIER_SCAN_FREQUENCY['complementary'],
            isSeasonal: destination.isSeasonal,
            seasonalPeriod: destination.isSeasonal ? {
              start: new Date(destination.seasonStart),
              end: new Date(destination.seasonEnd)
            } : undefined
          });
        }
      }
    }
    
    // Create routes in database
    await Route.insertMany(routes);
    console.log(`Initialized ${routes.length} strategic routes`);
  } catch (error) {
    console.error('Error initializing routes:', error);
  }
};

/**
 * Schedule route monitoring using cron jobs
 */
exports.scheduleRouteMonitoring = async () => {
  try {
    // Initialize routes if needed
    await exports.initializeRoutes();
    
    // Schedule different cron jobs for each tier
    
    // Ultra-priority routes: Every 4 hours (6 times per day)
    cron.schedule('0 */4 * * *', async () => {
      console.log('Running ultra-priority route monitoring...');
      await monitorRoutesByTier('ultra-priority');
    });
    
    // Priority routes: Every 6 hours (4 times per day)
    cron.schedule('0 */6 * * *', async () => {
      console.log('Running priority route monitoring...');
      await monitorRoutesByTier('priority');
    });
    
    // Complementary routes: Every 12 hours (2 times per day)
    cron.schedule('0 */12 * * *', async () => {
      console.log('Running complementary route monitoring...');
      await monitorRoutesByTier('complementary');
    });
    
    // Daily optimization of routes based on performance
    cron.schedule('0 2 * * *', async () => {
      console.log('Running daily route optimization...');
      await optimizeRoutesDaily();
    });
    
    // Monthly full optimization
    cron.schedule('0 3 1 * *', async () => {
      console.log('Running monthly full route optimization...');
      await optimizeRoutesMonthly();
    });
    
    console.log('Route monitoring scheduled successfully');
  } catch (error) {
    console.error('Error scheduling route monitoring:', error);
  }
};

/**
 * Monitor routes by tier
 * @param {string} tier - Route tier (ultra-priority, priority, complementary)
 */
async function monitorRoutesByTier(tier) {
  try {
    // Check API quota first
    const quota = await checkApiQuota();
    if (quota.remaining < 50) {
      console.log(`API quota too low (${quota.remaining} remaining). Skipping ${tier} routes monitoring.`);
      return;
    }
    
    // Get active routes for this tier
    const routes = await Route.find({ 
      tier, 
      isActive: true
    });
    
    console.log(`Found ${routes.length} active ${tier} routes to monitor`);
    
    // Check if seasonal routes should be active
    const now = new Date();
    const activeRoutes = routes.filter(route => {
      if (!route.isSeasonal) return true;
      
      const seasonStart = new Date(route.seasonalPeriod.start);
      const seasonEnd = new Date(route.seasonalPeriod.end);
      
      return now >= seasonStart && now <= seasonEnd;
    });
    
    console.log(`${activeRoutes.length} routes are currently in season`);
    
    // Process each route
    for (const route of activeRoutes) {
      await processRoute(route);
    }
    
  } catch (error) {
    console.error(`Error monitoring ${tier} routes:`, error);
  }
}

/**
 * Process a single route
 * @param {Object} route - Route object
 */
async function processRoute(route) {
  try {
    console.log(`Processing route ${route.departureAirport.code} to ${route.destinationAirport.code}`);
    
    // Update last scanned timestamp
    await Route.findByIdAndUpdate(route._id, {
      lastScannedAt: new Date(),
      $inc: { totalScans: 1 }
    });
    
    // Search for flights
    const flights = await searchFlights(
      route.departureAirport.code,
      route.destinationAirport.code
    );
    
    console.log(`Found ${flights.length} flights for ${route.departureAirport.code} to ${route.destinationAirport.code}`);
    
    // If no flights or no deals found, skip further processing
    if (!flights || flights.length === 0) {
      return;
    }
    
    // Filter for significant discounts only (potential deals)
    const potentialDeals = flights.filter(flight => flight.discountPercentage >= 20);
    
    if (potentialDeals.length === 0) {
      return;
    }
    
    console.log(`Found ${potentialDeals.length} potential deals`);
    
    // Update route success metrics
    await Route.findByIdAndUpdate(route._id, {
      $inc: { totalDealsFound: potentialDeals.length }
    });
    
    // Process each potential deal
    for (const deal of potentialDeals) {
      await processDeal(route, deal);
    }
    
  } catch (error) {
    console.error(`Error processing route ${route.departureAirport.code} to ${route.destinationAirport.code}:`, error);
  }
}

/**
 * Process a potential deal
 * @param {Object} route - Route object
 * @param {Object} deal - Deal object
 */
async function processDeal(route, deal) {
  try {
    // Validate deal using AI
    const isValidDeal = await validateDeal(deal);
    
    if (!isValidDeal) {
      console.log(`Deal validation failed for ${route.departureAirport.code} to ${route.destinationAirport.code}`);
      return;
    }
    
    // Get alternative dates for the same price
    const alternativeDates = await getAlternativeDates(route, deal);
    
    // Find users who should receive this alert
    const users = await findUsersForAlert(route, deal);
    
    if (users.length === 0) {
      console.log('No eligible users for this alert');
      return;
    }
    
    console.log(`Sending alert to ${users.length} users`);
    
    // Create alert and send emails
    for (const user of users) {
      await createAndSendAlert(user, route, deal, alternativeDates);
    }
    
  } catch (error) {
    console.error('Error processing deal:', error);
  }
}

/**
 * Get alternative dates for a deal
 * @param {Object} route - Route object
 * @param {Object} deal - Deal object
 * @returns {Promise<Array>} - Alternative dates
 */
async function getAlternativeDates(route, deal) {
  // This would call the getAlternativeDates function from flightService
  // For simplicity, we'll return an empty array
  return [];
}

/**
 * Find users who should receive an alert
 * @param {Object} route - Route object
 * @param {Object} deal - Deal object
 * @returns {Promise<Array>} - Array of eligible users
 */
async function findUsersForAlert(route, deal) {
  try {
    // Find users with matching departure airport
    const departureCode = route.departureAirport.code;
    const includeCDG = departureCode === 'CDG' || departureCode === 'ORY';
    
    let users;
    
    if (includeCDG) {
      // Users who specifically want CDG/ORY alerts
      users = await User.find({
        $or: [
          { departureAirports: departureCode },
          { includeCDG: true }
        ]
      });
    } else {
      // Users who have this airport in their preferences
      users = await User.find({
        departureAirports: departureCode
      });
    }
    
    // Filter users based on discount thresholds and alert limits
    const eligibleUsers = [];
    
    for (const user of users) {
      // Check if deal meets minimum discount threshold for user's subscription
      const minDiscount = user.subscriptionType === 'premium' ? MIN_DISCOUNT_PREMIUM : MIN_DISCOUNT_FREE;
      
      if (deal.discountPercentage < minDiscount) {
        continue;
      }
      
      // For free users, check daily alert limit
      if (user.subscriptionType === 'free') {
        // Get today's date (start of day)
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        
        // Count today's alerts for this user
        const alertCount = await Alert.countDocuments({
          user: user._id,
          createdAt: { $gte: today }
        });
        
        if (alertCount >= MAX_ALERTS_FREE) {
          continue;
        }
      }
      
      eligibleUsers.push(user);
    }
    
    return eligibleUsers;
  } catch (error) {
    console.error('Error finding users for alert:', error);
    return [];
  }
}

/**
 * Create an alert and send email to user
 * @param {Object} user - User object
 * @param {Object} route - Route object
 * @param {Object} deal - Deal object
 * @param {Array} alternativeDates - Alternative dates
 */
async function createAndSendAlert(user, route, deal, alternativeDates) {
  try {
    // Set expiry date (24 hours from now)
    const expiryDate = new Date();
    expiryDate.setHours(expiryDate.getHours() + 24);
    
    // Create alert in database
    const alert = new Alert({
      user: user._id,
      departureAirport: route.departureAirport,
      destinationAirport: route.destinationAirport,
      price: deal.price,
      originalPrice: deal.originalPrice,
      discountPercentage: deal.discountPercentage,
      discountAmount: deal.discountAmount,
      airline: deal.airline,
      farePolicy: deal.farePolicy || 'Standard',
      stops: deal.stops || 0,
      outboundDate: new Date(deal.departureDate),
      returnDate: new Date(deal.returnDate),
      duration: deal.duration,
      alternativeDates: alternativeDates.map(alt => ({
        outbound: new Date(alt.outbound),
        return: new Date(alt.return)
      })),
      bookingLink: deal.bookingLink,
      expiryDate: expiryDate
    });
    
    await alert.save();
    
    // Update user's total potential savings
    await User.findByIdAndUpdate(user._id, {
      $inc: { totalPotentialSavings: deal.discountAmount }
    });
    
    // Send email alert
    await sendAlertEmail(user, alert);
    
    console.log(`Alert sent to ${user.email} for ${route.departureAirport.code} to ${route.destinationAirport.code}`);
  } catch (error) {
    console.error('Error creating and sending alert:', error);
  }
}

/**
 * Daily optimization of routes based on performance
 */
async function optimizeRoutesDaily() {
  try {
    // Get current API quota
    const quota = await checkApiQuota();
    
    // Optimize routes based on performance and available quota
    const optimization = await optimizeRoutes({
      quota: quota.remaining,
      isFullOptimization: false
    });
    
    // Apply optimizations
    if (optimization.routesToUpdate && optimization.routesToUpdate.length > 0) {
      for (const routeUpdate of optimization.routesToUpdate) {
        await Route.findOneAndUpdate(
          {
            'departureAirport.code': routeUpdate.departureCode,
            'destinationAirport.code': routeUpdate.destinationCode
          },
          {
            scanFrequency: routeUpdate.newScanFrequency,
            tier: routeUpdate.newTier,
            isActive: routeUpdate.isActive
          }
        );
      }
      
      console.log(`Updated ${optimization.routesToUpdate.length} routes based on daily optimization`);
    }
  } catch (error) {
    console.error('Error optimizing routes daily:', error);
  }
}

/**
 * Monthly full optimization of routes
 */
async function optimizeRoutesMonthly() {
  try {
    // Get current API quota
    const quota = await checkApiQuota();
    
    // Perform full optimization
    const optimization = await optimizeRoutes({
      quota: quota.remaining,
      isFullOptimization: true
    });
    
    // Apply optimizations
    if (optimization.routesToUpdate && optimization.routesToUpdate.length > 0) {
      for (const routeUpdate of optimization.routesToUpdate) {
        await Route.findOneAndUpdate(
          {
            'departureAirport.code': routeUpdate.departureCode,
            'destinationAirport.code': routeUpdate.destinationCode
          },
          {
            scanFrequency: routeUpdate.newScanFrequency,
            tier: routeUpdate.newTier,
            isActive: routeUpdate.isActive
          }
        );
      }
      
      console.log(`Updated ${optimization.routesToUpdate.length} routes based on monthly optimization`);
    }
    
    // Handle new routes to add
    if (optimization.newRoutes && optimization.newRoutes.length > 0) {
      const newRoutes = optimization.newRoutes.map(newRoute => ({
        departureAirport: {
          code: newRoute.departureCode,
          name: newRoute.departureName
        },
        destinationAirport: {
          code: newRoute.destinationCode,
          name: newRoute.destinationName
        },
        tier: newRoute.tier,
        scanFrequency: TIER_SCAN_FREQUENCY[newRoute.tier],
        isSeasonal: newRoute.isSeasonal,
        seasonalPeriod: newRoute.isSeasonal ? {
          start: new Date(newRoute.seasonStart),
          end: new Date(newRoute.seasonEnd)
        } : undefined,
        isActive: true
      }));
      
      await Route.insertMany(newRoutes);
      console.log(`Added ${newRoutes.length} new routes based on monthly optimization`);
    }
    
    // Handle routes to remove
    if (optimization.routesToRemove && optimization.routesToRemove.length > 0) {
      for (const routeToRemove of optimization.routesToRemove) {
        await Route.findOneAndDelete({
          'departureAirport.code': routeToRemove.departureCode,
          'destinationAirport.code': routeToRemove.destinationCode
        });
      }
      
      console.log(`Removed ${optimization.routesToRemove.length} routes based on monthly optimization`);
    }
  } catch (error) {
    console.error('Error optimizing routes monthly:', error);
  }
}